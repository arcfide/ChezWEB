(@chezweb)

"\\centerline{\\titlefont ChezWEB Tangling}\\medskip
\\centerline{Aaron W. Hsu}\\bigskip
\\centerline{\\bf Introduction}\\bigskip
ChezWEB does not have the normal concept of tangling that is found in
CWEB, because a ChezWEB file is already a loadable Scheme program.
Instead, we provide this module which can be turned into a boot file and
treated like a normal Scheme application. When launched, the provided
REPL will be just like a normal Scheme REPL, but it will also have the
right settings to enable you to load, compile, and run ChezWEB programs.
"

(@l "
A single library |(arcfide chezweb tangle)| is defined that contains
all the usual definitions that need to be used."

(arcfide chezweb tangle)
(export @chezweb @> @* @ @c @< @l)
(import (chezscheme))

(@ "
A ChezWEB program should have a header |(@chezweb)| at the beginning of
its file. In a tangle program this is a no-op."

(@c
(define-syntax @chezweb
  (syntax-rules ()
    [(_) (begin)]))))

(@* "Control Codes" "
The primary control codes for ChezWEB are |@>|, |@<|, |@*|, |@|, and |@c|. The
|@>| control code handles the named section definitions.

A named section defines an isolated chunk of code that has a set of
imports, exports, and captures. Imports are valid Chez Scheme import
specifications, and exports are valid export specifications as defined
for modules. Captures are identifiers that, if free in the code chunk,
will capture bindings at the call site. That is, they are dynamically,
rather than lexically scoped.

A chunk can either be a value expression or a definition expression. In
the first case there will be no exports, and we can use a nil let form
to do our work. In the latter, we must use a module to encapsulate the
code chunk."

(@c
(define-syntax @>
  (syntax-rules ()
    [(_ name (i ...) () (c ...) e1 e2 ...)
     (define-syntax name
       (lambda (x)
         (syntax-case x ()
           [(k)
            (with-implicit (k c ...)
              #'(let ()
                  (import i ...)
                  e1 e2 ...))])))]
    [(_ name (i ...) (e ...) (c ...) e1 e2 ...)
     (define-syntax name
       (lambda (x) 
         (syntax-case x ()
           [(k)
            (with-implicit (k c ... e ...)
              #'(module (e ...)
                  (import i ...)
                  e1 e2 ...))])))]))))

(@ "
|@<| inserts the specified chunk into its call site. Naturally it
preserves the original scope and semantics as the chunk defines. Since
each chunk can be expanded itself, there is not reason to do anything
else here. We have this macro mostly to produce the correct woven 
code."

(@c
(define-syntax @<
  (syntax-rules ()
    [(_ id) (id)]))))

(@ "
The |@| control code wraps documentation, and since there is no reason
to evaluate documentation, just expand to the internal expressions."

(@c
(define-syntax @
  (syntax-rules ()
    [(_ documentation exp ...)
     (string? (syntax->datum #'documentation))
     (begin exp ...)]))))

(@ "
The |@*| control code is most the same as the |@| control code in that
we should just eliminate the documentation and evaluate the meaningful
subexpressions."

(@c
(define-syntax @*
  (syntax-rules ()
    [(_  level name documentation exp ...)
     (and (integer? (syntax->datum #'level))
          (exact? (syntax->datum #'level))
          (string? (syntax->datum #'name))
          (string? (syntax->datum #'documentation)))
     (begin exp ...)]
    [(_ name documentation exp ...)
     (and (string? (syntax->datum #'name))
          (string? (syntax->datum #'documentation)))
     (begin exp ...)]
    [(_ level name exp ...)
     (and (integer? (syntax->datum #'level))
          (exact? (syntax->datum #'level))
          (string? (syntax->datum #'name)))
     (begin exp ...)]
    [(_ name exp ...)
     (string? (syntax->datum #'name))
     (begin exp ...)]))))

(@ "
The |@c| is a top level code form, and is basically just another way
of writing |begin|."

(@c
(define-syntax @c
  (syntax-rules ()
    [(_ e1 e2 ...) (begin e1 e2 ...)]))))

(@ "
The |@l| form is designed to create a library. Its form is just like

a |library| form. This can only be used at the top level. In fact,
library forms are really tricky because they have their own 
environment. This means that you can't use the top-level definitions
that may be defined elsewhere in the file. Rather, you have to wrap
all of your sections inside of a library form. This makes things a
little inconvenient, but I know of no other way to handle it at the
moment."

(@c
(define-syntax @l
  (syntax-rules ()
    [(_ doc (n1 n2 ...) (export e ...) (import i ...) body ...)
     (and (string? (syntax->datum #'doc))
          (eq? 'export (syntax->datum #'export))
          (eq? 'import (syntax->datum #'import)))
     (library (n1 n2 ...)
       (export e ...)
       (import (arcfide chezweb tangle) i ...)
       body ...)]))))

)

(@* "Module Declaration" "
We really want to create an interaction environment that contains all
of the correct bindings for ChezWEB. To do this, we just need to import
the library that we just defined, and we get the benefits for free
when we use the boot file created from this file instead of the normal 
pettie.boot or scheme.boot. The boot file that is created should have 
a dependency on scheme.boot. "

(@c (import (arcfide chezweb tangle))))
