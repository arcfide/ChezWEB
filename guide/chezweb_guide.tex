\input eplain

\font\titlefnt = cmr17
\font\big = cmr12
\font\bigbf = cmb12

\def\heading#1{{\bigbf\bigskip\noindent #1\par\medskip}\noindent}

\null\vskip 3in
\centerline{\titlefnt ChezWEB User's Guide}
\vskip 1in
{\center Aaron W. Hsu
\tt arcfide@sacrideo.us
June 19, 2010}
\vfill
\noindent
Copyright $\copyright$ 2010 Aaron W. Hsu {\tt <arcfide@sacrideo.us>}. All rights reserved.\par
\noindent
This document may be redistributed without restriction provided that it is redistributed without fee and that it remains unaltered and unchanged from the original. Please report errors to the author.
\vfil\break

\doublecolumns

\heading{Prologue}%
Some time ago, the now Professor Emeritus of the Art of Computer
Programming Donald E. Knuth began writing programs.  Sometime after
that, he began to construct programs in a new manner.  This manner, he
documented and labeled ``Literate Programming.'' In Professor Knuth's
vision, a program is not constructed to be read by the machine, but
rather, to be read as a pleasant book is read, to be read by the
human.  In this way, one constructs and builds the pieces of a program
together, as you might build up the necessary elements of Math,
surrounding them with exposition, and ordering them in the manner that
best reveals the program's working and meaning to the reader.

This somewhat radical approach to programming leads to a drastically
different perspective on how to write programs.  Indeed, I feel that
writing my programs using Literate Programming has greatly improved my
ability to maintain and improve these same programs, and moreover, to
understand these programs as I am writing them.  I enjoy writing and
seeing the results of my writing, both in a printed or screen-readable
form, as well as in a machine executable form.

While I profess no particular skill in either writing or programming,
I do profess to enjoy both.  Indeed, this dual enjoyment is a
necessary condition for good programs, and is especially important in
Literate Programming, because it exposes your thoughts in two ways.
This enforced discipline can be embarassing at times, but inevitably
leads to a better programmer.

\heading{What is Literate Programming?}%
Before we move on to ChezWEB proper, no proper uses guide can
neglect discussing what Literate Programming actually means.  If you
already know what Literate Programming is, then feel free to move past
this chapter to the more technical details of ChezWEB.  Otherwise,
please take some time understanding the principles and motivations of
Literate Programming; by doing so, you will likely understand ChezWEB
better, and will make better use of its capabilities.

Firstly, Literate Programming is, in some sense, a way to document
your programs.  But true Literate Programming doesn't just encompass
the documentation aspects of programming.  Rather Literate Programming
is an approach both to writing code, as well as to writing
documentation.  The reader may have already encountered documentation
systems such as JavaDocs, which permit a sort of hypertext
documentation to be generated.  Class definitions can be documented
fairly quickly, and the whole system published in HTML.  One could use
a Literate Programming system to do this same sort of documentation,
but doing so misses the main point of Literate Programming.  In a
system like JavaDocs, the documentation is driven by the code.  That
is, the documentation and how one writes it centers around the the
layout, organization, and limitations of the programming language in
which the program components are written.  Secondly, Literate
Programming is an extension to normal programming languages.  It
enables the ability to reorder arbitrary chunks of code and then to
recompose them into some order.  This lets you write and order the
program in a manner that the interpreter or compiler for your language
may not accept.

Put together, Literate Programming is a combination of a documentation
and programming language, allowing you to restructure the presentation
of a program in a way that you see fit, rather than forcing you to
rely on specific conventions of the programming language.  Why is this
important?  When you write Literate Programs, you don't write them for
the computer.  Rather, you can look at a Literate Program as an essay
or a document to be read by humans.  In the same way that a textbook
of math or a mathematical paper may have formulas and definitions in
places to provide formal rigor, so the Literate Program uses program
code to rigorously express what is discussed in the text.  The text
receives a much greater focus in Literate Programming, and in fact,
neither documentation nor source code become the dominant feature of a
good Literate program.  The key is writing your programs in an
expository fashion, like you would write an essay or manual to be read
later by the human, rather than the computer.  This document just
happens to be executable as well as readable.

In essence, Literate Programming systems provide you the means of
constructing programs in a human readable, rather than computer
readable fashion, and to optimize them for such display.

In traditional WEB systems, this is accomplished by two programs, a
weaving program, and a tangling program.  Each program accepts a
document constructed of a series of sections, which have code and text
in them, and organizes them so that either the human or the computer
can read them easily.  The weave program generally outputs some
document that can be printed or read on the screen by the human, and
may include cross-references, links, references, and many other
things, such as pretty-printing.  The tangle program eliminates the
parts of the program that the computer doesn't need, namely, the text,
and ``tangles'' the code chunks into the order that the computer needs
in order to load the code.

In a traditional Literate Programming system, you specify sections,
which constitute a collection of text and code chunk.  Sections may
omit code or text from them, and some systems actually blur the line
between the end of one section and the start of another.  These code
chunks usually have names or they may be ``top-level'' chunks that are
used immediately in the code, and represent the initial starting
points for tangling the other named chunks.  The named chunks on the
other hand, will never end up in the tangled code unless they are
referenced by some other chunk.  When they are referenced, a named
code chunk takes the code associated with it and inserts it verbatim
in place of the reference.  In a sense, this is a form of programmatic
copy and paste.

Of course, as with any suitably powerful tool, you can misuse Literate
Programming.  Literate Programming should improve the quality of your
code, not reduce it.  Do not fall into the trap of thinking that just
because your program was written with a Literate Programming system
that it represents either good code, or good literate programs.  Keep
Literate Programming in its rightful place.  It is one of many tools
that exist to improve the quality of a piece of software.

\heading{Scheme and Traditional Literate Programming}%
Let's take a quick moment to discuss the Scheme programming language
and combining it together with traditiona Literate Programming
systems.  Generally speaking, there are two sorts of Literate
Programming systems which fall under the traditional categorization.
Programs like CWEB and WEB, which Knuth uses, are tightly integrated
into the programmling language around which they work.  They are also
tied rather directly to the documentation language that they use.
There are many different special purpose constructs that you use to
dictate how your program is organized and used.  For example, CWEB has
a special place in each section for macro definitions.  This isn't
something you would see in most other languages, because they don't
have macros in the same sense that C does.  Likewise, there are other
specific control code used to handle specific things you would only
want to do in C. While these systems provide you with a really high
level of integration, they don't port well to other programming
languages.  Because of this problem, other systems have cropped up
that don't care what documentation or programming language you use, so
long as the syntax for either does not conflict with the limited
syntax of the Literate Programming system.  Noweb is a popular choice
for this sort of agnostic Literate Programming.  Noweb uses very few
control codes, and does not pretty printing or language specific
things out of the box.  You hook into the noweb system in various
places to enable this sort of feature, but it isn't something that
most people do.  These systems have a critical advantage to some
users, in that you can use them with any language.  If you use many
different languages and want to use the same Literate Programming
system throughout, or if, perhaps, you do not have a CWEB-like system
for your particular programming language these sorts of agnostic
Literate Programming systems make much sense.

Scheme has a few Literate Programming systems or documentation tools
that work a little like Literate Programming designed specifically for
it.  SchemeWEB is a way of generating formatted comments next to
verbatim listings of code.  S\LaTeX is another example of a
documentation system, but it doesn't let you run code.  It's more of a
listing environment for Scheme code.  Unfortunately, neither of these
systems is really a full-blown Literate Programming system.  SLaTeX
doesn't let you run the code you write, and SchemeWEB doesn't allow
you to reorder your program.  In the Traditional Literate Programming
world, Scheme has no CWEB analogue.  Thus, using an agnostic Literate
Programming system is really your only choice if you want to write
traditional literate programs in Scheme.

I should point out that there are some other systems that do have
Scheme specific Literate Programming.  A notable example is the
Scribble/LP system.  It has the advantage of being written in Scheme,
and as a language in the PLT umbrella, it supports loading and running
the code directly, without requiring the use of a preprocessor like
tangle.  However, Scribble is difficult to implement natively without
a means of extending the reader.  This limits it to implementations
where the authors of the implementation have added Scribble support,
or that enable reader extensions by the user.  Still, Scribble/LP is
one of the best examples of a traditional Literate Programming system
designed specifically for Scheme.

Now would be a good time to discuss some of the unique results of
Literate Programming and Scheme.  The most interesting point relates
to the hygiene of Literate Programming.  You can think of Literate
Programming as a form of macro language on top of the language the
system surrounds.  In most other programming languages, only rather
limited macro systems exist, and almost none are hygienic.
Traditional Literate Programming is also not hygienic.  When you
reference a chunk of code somewhere, it really is just like you had
copied and pasted it directly in there, before loading the program.
If you define something in one chunk, and then reference that chunk in
some other, the definitions will get scoped where they were
referenced, and will capture or shadow any bindings accordingly.  This
differs rather significantly from Scheme macros, which preserve
hygiene by default.  So, if we think of Literate Programming as an
extra macro system on top of Scheme, you're wrapping a rather
sophisticated fully general macro language in Scheme with a completely
unhygienic system.

There is nothing wrong with traditional Literate Programming, but when
I write in Scheme, I want more.  Thus, I wrote ChezWEB.

\heading{What is ChezWEB?}%
ChezWEB is a literate programming system for the R6RS Scheme language.
It is implemented using Chez Scheme, but there is no reason it could
not also be ported to other Scheme implementations as well.  It allows
you to reorder code and to organize your program into a series of
sections.  Each of these sections contain documentation or code.  It
was modelled after the CWEB system, and programming with ChezWEB is a
little like programming with CWEB.  However, CWEB is a WEB Literate
Programming system for the C language, which has a number of
restrictions that do not exist in Scheme.

ChezWEB has a number of advantages over using traditional systems.
For one, if you wanted to write Literate Programs in Scheme, you had
no option but to use a language agnostic system such as noweb to do
so.  While you could hack on noweb's piping shell script model to get
some amount of Scheme language recognition, doing so might have caused
you more than a few headaches.  ChezWEB is written in Scheme, and in
fact, it is implemented as a couple of libraries, one that provides
documentation support, and the other that provides the language
support for executing ChezWEB programs.  The forms defined by the
ChezWEB system are just normal Scheme forms, implemented as macros.
This means that you get all the advantages of Scheme when using
ChezWEB.  ChezWEB knows about things like hygiene and modules and it
also understands the workflow of most Schemers.

Most Schemers do not follow an edit-build-run-debug workflow.  This
workflow requires an usually annoying and unnecessary build phase
where you must build your program before you can run and experiment
with it.  Most Schemers like to program on a REPL, where they can
interactively define and play with software as they are working.  They
like to load files in directly after changing them with their editors,
and maybe copy and paste new elements right into their REPL, without
even writing them to a file first.  ChezWEB supports this model.  Once
you enable ChezWEB on your REPL, you can load ChezWEB programs just
the same way you would have loaded any normal Scheme program, and you
can also enter ChezWEB code directly on the REPL, and it will get
evaluated just like normal Scheme, because, it really is just normal
Scheme.

ChezWEB consists of two libraries, and two wrappers on those
libraries.  The ChezWEAVE library provides support for producing
documentation from the program.  It outputs \TeX\ code, and the
chezweave program wraps this library to provide a convenient interface
for generating or ``weaving'' the program into a printable,
human-readable format.

\heading{Structure of a ChezWEB program}%
Every ChezWEB program is composed of a series of sections. These sections are groups of documentation and code chunks. When dealing with R6RS Libraries, a set of sections may be encased in a ChezWEB library directive, which documents the actual library form. There are three groups of ChezWEB forms: documentation forms, code forms, and other miscellaneous forms that may involve documentation and code. The typical ChezWEB library might look something like this:

\medskip\verbatim
(@chezweb)

(@l "<documentation>"

(library name)
(export <export-spec> ...)
(import <import-spec> ...)

<section> ...

)
|endverbatim
\medskip

\noindent
The \verbatim export-spec|endverbatim and \verbatim import-spec|endverbatim forms are the same as the R6RS import and export forms. \verbatim Sections|endverbatim are any valid ChezWEB section. 

To summarize the forms in ChezWEB, here is a list:

\medskip
\itemitem{Code}
\verbatim @c @> @< @<< |endverbatim
\itemitem{Doc.}
\verbatim @ @* |endverbatim
\itemitem{Misc.}
\verbatim @l @chezweb |endverbatim
\medskip

\noindent


\bye
