\input eplain

\font\titlefnt = cmr17
\font\big = cmr12
\font\bigbf = cmb12

\def\heading#1{{\bigbf\bigskip\noindent #1\par\medskip}\noindent}

\null\vskip 3in
\centerline{\titlefnt ChezWEB User's Guide}
\vskip 1in
{\center Aaron W. Hsu
\tt arcfide@sacrideo.us
June 19, 2010}
\vfill
\noindent
Copyright $\copyright$ 2010 Aaron W. Hsu {\tt <arcfide@sacrideo.us>}. All rights reserved.\par
\noindent
This document may be redistributed without restriction provided that it is redistributed without fee and that it remains unaltered and unchanged from the original. Please report errors to the author.
\vfil\break

\doublecolumns

\heading{Prologue}%
Some time ago, the now Professor Emeritus of the Art of Computer
Programming Donald E. Knuth began writing programs.  Sometime after
that, he began to construct programs in a new manner.  This manner, he
documented and labeled ``Literate Programming.'' In Professor Knuth's
vision, a program is not constructed to be read by the machine, but
rather, to be read as a pleasant book is read, to be read by the
human.  In this way, one constructs and builds the pieces of a program
together, as you might build up the necessary elements of Math,
surrounding them with exposition, and ordering them in the manner that
best reveals the program's working and meaning to the reader.

This somewhat radical approach to programming leads to a drastically
different perspective on how to write programs.  Indeed, I feel that
writing my programs using Literate Programming has greatly improved my
ability to maintain and improve these same programs, and moreover, to
understand these programs as I am writing them.  I enjoy writing and
seeing the results of my writing, both in a printed or screen-readable
form, as well as in a machine executable form.

While I profess no particular skill in either writing or programming,
I do profess to enjoy both.  Indeed, this dual enjoyment is a
necessary condition for good programs, and is especially important in
Literate Programming, because it exposes your thoughts in two ways.
This enforced discipline can be embarassing at times, but inevitably
leads to a better programmer.

\heading{What is Literate Programming?}%
Before we move on to ChezWEB proper, no proper uses guide can
neglect discussing what Literate Programming actually means.  If you
already know what Literate Programming is, then feel free to move past
this chapter to the more technical details of ChezWEB.  Otherwise,
please take some time understanding the principles and motivations of
Literate Programming; by doing so, you will likely understand ChezWEB
better, and will make better use of its capabilities.

In some sense, Literate Programming is a way to document
your programs, but true Literate Programming doesn't just encompass
the documentation aspects of programming.  Rather Literate Programming
is an approach both to writing code, as well as to writing
documentation.  The reader may have already encountered documentation
systems such as JavaDocs, which permit a sort of hypertext
documentation to be generated.  Class definitions can be documented
fairly quickly, and the whole system published in HTML.  One could use
a Literate Programming system to do this same sort of documentation,
but doing so misses the main point of Literate Programming.  In a
system like JavaDocs, the documentation is driven by the code.  That
is, the documentation and how one writes it centers around the the
layout, organization, and limitations of the programming language in
which the program components are written.  Secondly, Literate
Programming is an extension to normal programming languages.  It
enables the ability to reorder arbitrary chunks of code and then to
recompose them into some order.  This lets you write and order the
program in a manner that the interpreter or compiler for your language
may not accept.

Put together, Literate Programming is a combination of a documentation
and programming language, allowing you to restructure the presentation
of a program in a way that you see fit, rather than forcing you to
rely on specific conventions of the programming language.  Why is this
important?  When you write Literate Programs, you don't write them for
the computer.  Rather, you can look at a Literate Program as an essay
or a document to be read by humans.  In the same way that a textbook
of math or a mathematical paper may have formulas and definitions in
places to provide formal rigor, so the Literate Program uses program
code to rigorously express what is discussed in the text.  The text
receives a much greater focus in Literate Programming, and in fact,
neither documentation nor source code become the dominant feature of a
good Literate program.  The key is writing your programs in an
expository fashion, like you would write an essay or manual to be read
later by the human, rather than the computer.  This document just
happens to be executable as well as readable.

In essence, Literate Programming systems provide you the means of
constructing programs in a human readable, rather than computer
readable fashion, and to optimize them for such display.

Traditional WEB systems accomplish this using two programs, a
weaving program, and a tangling program.  Each program accepts a
document constructed of a series of sections, which have code and text
in them, and organizes them so that either the human or the computer
can read them easily.  The weave program generally outputs some
document that can be printed or read on the screen by the human, and
may include cross-references, links, references, and many other
things, such as pretty-printing.  The tangle program eliminates the
parts of the program that the computer doesn't need, namely, the text,
and ``tangles'' the code chunks into the order that the computer needs
in order to load the code.

In a traditional Literate Programming system, you specify sections,
which constitute a collection of text and code chunk.  Sections may
omit code or text from them, and some systems actually blur the line
between the end of one section and the start of another.  These code
chunks usually have names or they may be ``top-level'' chunks that are
used immediately in the code, and represent the initial starting
points for tangling the other named chunks.  The named chunks on the
other hand, will never end up in the tangled code unless they are
referenced by some other chunk.  When they are referenced, a named
code chunk takes the code associated with it and inserts it verbatim
in place of the reference.  In a sense, this is a form of programmatic
copy and paste.

Of course, as with any suitably powerful tool, you can misuse Literate
Programming.  Literate Programming should improve the quality of your
code, not reduce it.  Do not fall into the trap of thinking that just
because your program was written with a Literate Programming system
that it represents either good code, or good literate programs.  Keep
Literate Programming in its rightful place.  It is one of many tools
that exist to improve the quality of a piece of software.

\heading{Scheme and Traditional Literate Programming}%
First, let's discuss the Scheme in the context of traditional Literate
Programming tools. Generally, two sorts of Literate
Programming systems exist.  These fall under the traditional
categorization.
Programs like CWEB and WEB, which Knuth uses, are tightly integrated
into the programming language around which they work.  They are also
tied rather directly to the documentation language that they use.
There are many different special purpose constructs that you use to
dictate how your program is organized and used.  For example, CWEB has
a special place in each section for macro definitions.  This isn't
something you would see in most other languages, because they don't
have macros in the same sense that C does.  Likewise, there are other
specific control code used to handle specific things you would only
want to do in C. While these systems provide you with a really high
level of integration, they don't port well to other programming
languages.  Because of this problem, other systems have cropped up
that don't care what documentation or programming language you use, so
long as the syntax for either does not conflict with the limited
syntax of the Literate Programming system.  Noweb is a popular choice
for this sort of agnostic Literate Programming.  Noweb uses very few
control codes, and does not pretty printing or language specific
things out of the box.  You hook into the noweb system in various
places to enable this sort of feature, but it isn't something that
most people do.  These systems have a critical advantage to some
users, in that you can use them with any language.  If you use many
different languages and want to use the same Literate Programming
system throughout, or if, perhaps, you do not have a CWEB-like system
for your particular programming language these sorts of agnostic
Literate Programming systems make much sense.

Scheme has a few Literate Programming systems or documentation tools
that work a little like Literate Programming designed specifically for
it.  SchemeWEB is a way of generating formatted comments next to
verbatim listings of code.  S\LaTeX is another example of a
documentation system, but it doesn't let you run code.  It's more of a
listing environment for Scheme code.  Unfortunately, neither of these
systems is really a full-blown Literate Programming system.  SLaTeX
doesn't let you run the code you write, and SchemeWEB doesn't allow
you to reorder your program.  In the Traditional Literate Programming
world, Scheme has no CWEB analogue.  Thus, using an agnostic Literate
Programming system is really your only choice if you want to write
traditional literate programs in Scheme.

I should point out that there are some other systems that do have
Scheme specific Literate Programming.  A notable example is the
Scribble/LP system.  It has the advantage of being written in Scheme,
and as a language in the PLT umbrella, it supports loading and running
the code directly, without requiring the use of a preprocessor like
tangle.  However, Scribble is difficult to implement natively without
a means of extending the reader.  This limits it to implementations
where the authors of the implementation have added Scribble support,
or that enable reader extensions by the user.  Still, Scribble/LP is
one of the best examples of a traditional Literate Programming system
designed specifically for Scheme.

Now would be a good time to discuss some of the unique results of
Literate Programming and Scheme.  The most interesting point relates
to the hygiene of Literate Programming.  You can think of Literate
Programming as a form of macro language on top of the language the
system surrounds.  In most other programming languages, only rather
limited macro systems exist, and almost none are hygienic.
Traditional Literate Programming is also not hygienic.  When you
reference a chunk of code somewhere, it really is just like you had
copied and pasted it directly in there, before loading the program.
If you define something in one chunk, and then reference that chunk in
some other, the definitions will get scoped where they were
referenced, and will capture or shadow any bindings accordingly.
Scheme macros differ significantly from this model, which preserve
hygiene by default.  So, if we think of Literate Programming as an
extra macro system on top of Scheme, do you really want to wrap the
sophisticated Scheme macro system with a rather na\"\i ve unhygienic
one?

There is nothing wrong with traditional Literate Programming, but when
I write in Scheme, I want more.  Thus, I wrote ChezWEB.

\heading{What is ChezWEB?}%
ChezWEB is a literate programming system for the R6RS Scheme language.
It is implemented using Chez Scheme, but there is no reason it could
not also be ported to other Scheme implementations as well.  It allows
you to reorder code and to organize your program into a series of
sections.  Each of these sections contain documentation or code.  It
was modelled after the CWEB system, and programming with ChezWEB is a
little like programming with CWEB.  However, CWEB is a WEB Literate
Programming system for the C language, which has a number of
restrictions that do not exist in Scheme.

ChezWEB has a number of advantages over using traditional systems.
For one, if you wanted to write Literate Programs in Scheme, you had
no option but to use a language agnostic system such as noweb to do
so.  While you could hack on noweb's piping shell script model to get
some amount of Scheme language recognition, doing so might have caused
you more than a few headaches.  ChezWEB is written in Scheme, and in
fact, it is implemented as a couple of libraries, one that provides
documentation support, and the other that provides the language
support for executing ChezWEB programs.  The forms defined by the
ChezWEB system are just normal Scheme forms, implemented as macros.
Thus, you get all the advantages of Scheme when using
ChezWEB.  ChezWEB understands hygiene and modules and it
also understands the workflow of most Schemers.

Most Schemers do not follow an edit-build-run-debug workflow.  This
workflow requires an usually annoying and unnecessary build phase
where you must build your program before you can run and experiment
with it.  Most Schemers like to program on a REPL, where they can
interactively define and play with software as they are working.  They
like to load files in directly after changing them with their editors,
and maybe copy and paste new elements right into their REPL, without
even writing them to a file first.  ChezWEB supports this model.  Once
you enable ChezWEB on your REPL, you can load ChezWEB programs just
the same way you would have loaded any normal Scheme program, and you
can also enter ChezWEB code directly on the REPL, and it will get
evaluated just like normal Scheme, because, it really is just normal
Scheme.

ChezWEB consists of two libraries, and two wrappers on those
libraries.  The ChezWEAVE library provides support for producing
documentation from the program.  It outputs \TeX\ code, and the
chezweave program wraps this library to provide a convenient interface
for generating or ``weaving'' the program into a printable,
human-readable format.

\heading{Structure of a ChezWEB program}%
Every ChezWEB program is composed of a series of sections.  These
sections are groups of documentation and code chunks.  When dealing
with R6RS Libraries, a set of sections may be encased in a ChezWEB
library directive, which documents the actual library form.  ChezWEB
has three types of forms: documentation forms, code forms, and
other miscellaneous forms that may involve documentation and code.
The typical ChezWEB library might look something like this:

\medskip\verbatim
(@chezweb)

(@l "<documentation>"

(library name)
(export <export-spec> ...)
(import <import-spec> ...)

<section> ...

)
|endverbatim
\medskip

\noindent
The 
\verbatim export |endverbatim 
and 
\verbatim import |endverbatim 
specifications are the same as the R6RS import and
export forms.  
\verbatim Sections |endverbatim 
are any valid ChezWEB
section.  The 
\verbatim @chezweb |endverbatim 
form should be at the top
of every ChezWEB program.

To summarize the forms in ChezWEB, here is a list:

\medskip
\itemitem{Misc.}
\verbatim @l @chezweb |endverbatim
\itemitem{Doc.}
\verbatim @ @* |endverbatim
\itemitem{Code}
\verbatim @c @> @< @<< |endverbatim
\medskip

\noindent
In the next three sections I will detail the operation of each of
these forms.  Firstly, though, I would like to give the basic
structure of a section.  Normally, a section will consist of one
documentation form encapsulating one code form.  This is the way that
ChezWEB is designed to work, but there are other ways that you can do
things and still get decent results.  ChezWEB was organized in this
way primarily for providing good printed output, even though the code
side of the system is more flexible than that.  I have not developed
an useful way of thinking about these forms when they are deeply
nested, at least, not when it comes to formatting it into something
pretty.

\heading{Documentation Forms}%
The documentation forms are in charge of capturing and formatting the
documentation parts of the WEB program.  Primarily, they are ways of
connecting strings, which form elements of the documentation, with
code for formatting and indexing.  An example of the most basic
documentation form is the {\tt @} sign.

\verbatimescapechar \#
\medskip\verbatim
(@
"This is a procedure called |loop|
without $\lambda$."

(@c
(define (loop) (loop))
))
#endverbatim
\medskip

\verbatimescapechar |

\noindent
The above will eventually form a numbered section with ``This is a
procedure'' as its text and the code below as its code.  For example,
if it is the third section in a WEB document, you may get something
like this:

\bigskip\hrule\smallskip
{\narrower \noindent {\bf 3.} This is a procedure called {\tt loop}
without $\lambda$.\par
\noindent $<*>\equiv$\par
\verbatim
(define (loop)
  (loop))
|endverbatim
\smallskip\hrule\bigskip}

\noindent
The $<*>\equiv$ is the way that ChezWEB marks out top-level code
elements.  See the documentation of the code forms below for more
information.  For every section, ChezWEB prints a running number that
indicates the number of the section.  This is used when referring to
that section in the index or the table of contents.  Notice also that
the documentation strings, such as that used above is just a normal
string of \TeX\ code.  Actually, it's eplain Plain \TeX\ combined with
a special form for the vertical bar, which let's you quote things
inline using the vertical bar.  This makes it more convenient to talk
about various types that you want to verbatim or list inline without
having to use your own custom verbatim environment.

The actual format of the {\tt @} form is as follows:

\medskip\verbatim
(@ doc-string code-chunk ...)
|endverbatim
\medskip

\noindent
It is not always necessary to use code chunks in any one given
documentation chunk, so you may choose to not put any chunks in the
documentation; only the documentation string is required.

The {\tt @*} form is much like the {\tt @} form, but it indicates the
beginning of a named section.  The form is as follows:

\medskip\verbatim
(@* head-string doc-string 
  code-chunk ...)
|endverbatim
\medskip

\noindent
The {\tt head-string} consist of a string that will be used as the
title of the section, typeset in a bold font.  The {\tt doc-string} is
the same as with the {\tt @} form.  The above form is currently the
only supported form, but additional forms should be supported in newer
versions of ChezWEB.

\heading{Code Forms}%
There are four code forms.  The simplest form, {\tt @c}, is
essentially a special form of the Scheme {\tt begin} form.  Generally
speaking, you would use {\tt @c} whenever you want to put code at the
top-level.  There is no indirection or copying that goes on here.
It's just inserting the code directly as it is shown into the code.
For programs that are fairly simple, and which can be appropriate
organized at the procedure level, using {\tt @c} usually suffices.

Whenever you have programs with complicated internals that deserve
their own separate section, or if you have additional reorganization
that you want to make which Scheme doesn't support, which is usually
in the form of lifting code or syntax out to the top-level for
exposition, you will want to define named code chunks that can be used
or inserted into other code.  The {\tt @>} form defines a chunk.  It
has the following syntax:

\medskip\verbatim
(@> id-name id-spec exp ...)
|endverbatim
\medskip

\noindent
The {\tt id-spec} forms are a set of specifications where each is of
one of the following forms:

\medskip\verbatim
(export id ...)
(import imp-spec ...)
(capture id ...)
|endverbatim

\noindent You can only have one of the above forms per defined chunk,
so a named code chunk will have at most three binding specifiers.
They may be specified in any order, and any one of them may be
omitted.  The {\tt import} form works just like the normal Chez Scheme
{\tt import} form.  The {\tt export} form controls what bindings are
visible outside of the scope of the code chunk whenever that code
chunk is used.  The {\tt capture} form specifies what identifiers
should be visible from the call site context whenever the code chunk
is used.  The {\tt export} form takes the normal form of the Chez {\tt
module} form.

As an example, imagine we wish to write a program that
discusses some internal definition, and then uses that definition
inside of some {\tt let} expression.  We may want to lift the internal
definition to the top-level and provide some key exposition on how it
works or why it exists.  It wouldn't look very nice if we just did
this with a comment inside of the actual {\tt let} expression, and
with ChezWEB, we don't have to do this.  Instead, we can do something
like the following ChezWEB program:

\verbatimescapechar \#
\medskip\verbatim
(@chezweb)

(@ "This is our internal procedure."

(@> |Define internal proc|
(export do-something)
(capture x)
(define (do-something)
  (display x)
  (newline))
))

(@ "Here's our |let|."

(@c
(let ([x 5])
  (@< |Define internal proc| x)
  (do-something))
))
#endverbatim
\medskip\verbatimescapechar |

\noindent The output of this program if we were to load it with the
Tangle environment, or using the 
\verbatim cheztangle |endverbatim
 program would be
something like this:

\medskip\verbatim
$ cheztangle -q foo.w
5
>
|endverbatim
\medskip

\noindent
Now, if we were to weave this program, we would get something like
this:

\bigskip\hrule\smallskip
{\narrower\noindent{\bf 1.} This is our internal procedure.\par
\noindent $\langle$Define internal proc$\rangle\equiv$\par
\verbatim
(define (do-something)
  (display x)
  (newline))
|endverbatim
\medskip
\noindent{\it Exports:} {\tt do-something}\par
\noindent {\it Captures:} {\tt x}\medskip
{\noindent\bf 2.} Here's our {\tt let}.\par
\noindent $\langle *\rangle\equiv$\par
\verbatim
(let ([x 5])
  |endverbatim $\langle$Define internal proc 1$\rangle$\par\verbatim
  (do-something))
|endverbatim
\smallskip
\hrule
\bigskip}

\noindent
Notice that when we define a named chunk, we also can see what
exports, captures, and imports that we have.  When we use a named
chunk, we will get told where to find the definition of that chunk.

As you may have guessed from the above example, captures are taken
from the call site, but these are threaded explicitly through to the
named chunk.  The chunks are completely hygienic, meaning that
bindings do not spill out of the chunk when they are not exported, and
chunks are referentially transparent, meaning that they do not capture
identifiers at their call site unless they are given them in the form
of captures.

You may also have deduced the behavior of {\tt @<}, but you should be
careful there.  There are two forms which insert named code chunks
into various places.  They are exactly the same, but for the way that
they thread the exports of a named chunk.  With {\tt @<}, no explicit
threading is performed, and identifiers are inserted directly into the
scope of the chunk in which the {\tt @<} form occurs.  This has
important ramifications for named code chunks that have occurances of
{\tt @<} in them, since any bindings exported by that reference will
only be visible inside the named code chunk.  This is similar to the
{'tt include} problem, where bindings defined by include are visible
only where the {\tt include} form occurs, and not outside of it, which
some people expect.  To illustrate this point, take the following
example; this code will not run, but will instead result in an error:

\verbatimescapechar \#
\medskip\verbatim
(@chezweb)

(@ ""
(@> |My A| (export a)
(define a 3)
))

(@ ""
(@> |My A again| (export a)
(@< |My A|)
))

(@ ""
(@c
(@< |My A again|)
(display a) (newline)
))
#endverbatim
\medskip

\verbatimescapechar |

\noindent
In the above code, when we attempt to load this program, we will get
an error that {\tt a} is not defined.  The reason is that we have tried
to use the A binding outside of where it is visible.  We have two code
chunks that are attempting to export the same binding.  The second
binding will be made visible at the call site, but the insertion from
the ``My A'' code chunk will only be visible inside of the ``My A
again'' chunk, which means that the A will not be defined or visible
at the call site.  Put simply, if you want to re-export a binding, you
need to thread the bindings through.  This requires that you use the
{\tt @<<} form, which is the same as the {\tt @<} form, except that it
threads the bindings back through if they are re-exported.

Sometimes more care about what is bound and not bound is required than
you can get with just {\tt @<<} alone.  In that case, you may have to
do some explicit capturing using the {\tt capture} form, which will
give you precise control over the threading.

Both {\tt @<} and {\tt @<<} have the same basic syntax:

\medskip\verbatim
(@< chunk-name captures ...)
|endverbatim
\medskip

\noindent
That's about all there is to it.  There really are not too many
control codes to worry about, but some care must be taken when doing
Hygienic Literate Programming, even though you get nice additional
guarantees and some assurances.  The next section describes the
general forms that aren't really documentation or code forms.

One important note about named chunks is that they must be defined
before they can be used.  If you are using it inside of another chunk,
this really only comes into play if that other named chunk is used
before the called chunk is defined.  This basically means that if you
plan to use a named chunk inside of a top-level unnamed chunk, you
need to put the named chunk before the unnamed chunk.  This normally
isn't a problem, but in those cases where it really doesn't make sense
to put the named chunk above the unnamed chunk, it sometimes makes
sense to wrap what you would normally put into the unnamed chunk into
another named chunk, and then use that named chunk inside an unnamed
chunk at the end of all of the named chunks in the group.

\heading{Miscellaneous Forms}%
The two forms here are really meta-level forms.  The first, {\tt
@chezweb} is simply a token that you should put at the top of every
one of your files, as we have done here.  The {\tt @l} form is a form
that documents a library, and wraps a series of sections.  These
sections are then restricted in scope to the given library.  It has
the following syntax:

\medskip\verbatim
(@l doc-string

library-spec
(export export-spec ...)
(import import-spec ....)

sections ...)
|endverbatim
\medskip

\noindent
The specifications are the same as their R6RS analogues.  The
documentation string is the same as any other documentation string,
except that it will be formatted fairly close to the top of the
library.

\bye
