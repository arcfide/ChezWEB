\null\vfill
\centerline{\titlefont ChezWEB System of Structured Documentation}
\vskip 18pt
\centerline{Version 0.1 --- Thursday, March 4th, 2010}
\vskip 24pt
\centerline{Aaron W. Hsu}
\vfill
\noindent Copyright $\copyright$ 2010 by Aaron W. Hsu.
\smallskip

\noindent Permission to use, copy, modify, and distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.\smallskip

\noindent {\bf The software is provided ``as is'' and the author disclaims all
warranties with regard to this software including all implied warranties
of merchantability and fitness. In no event shall the author be liable
for any special, direct, indirect, or consequential damages or any
damages whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action, arising
out of or in connection with the use or performance of this
software.\smallskip}\par\break

(@* "Introduction" "
CWEB is a nice, full-featured implementation of the WEB philosophy of
programming, but it is extremely C specific. Some implementations of
literate programming exist that are language agnostic, such as Noweb.
However, I like the in-depth knowledge of C that CWEB brings into its
language. Since I use Scheme, I would like to have a system of WEB
programming that does in fact, integrate well with Scheme. Moreover, I
do not wish to supplant the features already available in a rich and
expressive language such as Scheme. Instead, I just wish to provide a
sophisticated, integrated WEB programming system that utilizes what
Scheme brings to the table.

How can I do this? My basic thesis is that with minimal changes to the
existing ideas behind CWEB, I can provide a similarly language centric
version of CWEB for Scheme. In order to do this, some control codes will
have to be removed, and others provided. I will have to change the
syntax in some ways, and I will have to alter behavior in other places,
but otherwise, I wish to preserve the overal feel of programming in
CWEB, but for Scheme.

The interface is designed to be as close to CWEB as possible, and the
workflow is mostly the same. The main differences are as follows:

\\unorderedlist
\\li Chunks are S-Expressions
\\li Some control codes are not useful for Scheme, and thus, do not
exist.
\\li Code chunks require free variables to be declared, otherwise they
inherit the bindings that they find from the top-level of the program.
\\li Macros are Scheme macros, and no control codes exist for them.
\\li Some of the output in \\TeX is tweaked for Scheme.
\\endunorderedlist

Programs are either weaved or tangled in the same way that normal CWEB
programs are. Two programs exist, ChezWEAVE and ChezTANGLE. They work
mostly in the same way that CWEAVE and CTANGLE work. For more
information on them, please see their documentation.")

(@* "Limitations" "
Because we are actually using Scheme macros to represent chunks, it is
not possible for us to throw macros everywhere. Instead, all chunks are
actually defined as real Scheme macros that just happen to expand out
usefully.")

(@* "Control Codes" "
While the weave and tangle programs exist separately, they both rely on
the use of a common set of control code macros. These are actually
Scheme macros. The set of codes is defined here, and the specific
functionality for each program is provided by the programs.

This file defines the control codes by declaring a mutually recursive
module. The module itself is dependent on a module |output-procedures|
that is provided by either the weave or tangle program. This module is
expected to provide all the correct rendering procedures for actually
sending the section data to a port. Generally speaking, each control
code outputs or affects the output of the ChezWEB program that is being
weaved or tangled. In essence, to generate a tangled file, you run the
ChezWEB program with certain parameters, and to weave a file, you change
those parameters and run the program that you have defined in your
ChezWEB file. 

Each control code has a corresponding |render-*| procedure that matches
its signature. When it comes from the tangling program, then it should
generate valid Scheme code to the output in the correct order. When it
comes from the weaving program, then it will output \\TeX code in the
correct order. See the note in (@< \"@* Definition\").
"

(@c
(module control-codes 
  (@* @ @f @s @d @c @p @l @> @-> @^ @. @: @t @! @i compile-web-file)
  (import (chezscheme))
  (import output-procedures)
  
(@< "Program Framework")
(@< "Utilities")
(@< "@* Definition")
(@< "@ Definition")
(@< "@f Definition")
(@< "@s Definition")
(@< "@c Definition")
(@< "@p Definition")
(@< "@l Definition")
(@< "@> Definition")
(@< "@-> Definition")
(@< "@^ Definition")
(@< "@. Definition")
(@< "@: Definition")
(@< "@t Definition")
(@< "@! Definition")
(@< "@i Definition")

)))

(@ " 
The \\.{@*} control code corresponds directly to the CWEB control code
of the same name. It is a named section. There are a few incantations.
There must be a section name, but this may be followed by an optional
documentation string and an optional code chunk. It may also be prefixed
by an indentation level. The section name and documentation should both
be strings, while the indent level should be a literal exact integer
that is greater than or equal to $-1$. 

Notice the use of |delay| here. Since we want the rendering to go in
order, we delay the execution of the code chunk until it is ready."

(@> "@* Definitions" (output-procedures) ((@* render-@*)) ()
(define-syntax @*
  (syntax-rules ()
    [(_ section code)
     (and (string? (syntax->datum #'section))
          (code-chunk? #'code))
     (render-@* 0 section "" code)]
    [(_ section documentation)
     (and (string? (syntax->datum #'section))
          (string? (syntax->datum #'documentation)))
     (render-@* 0 section documentation (begin))]
    [(_ section documentation code)
     (and (string? (syntax->datum #'section))
          (string? (syntax->datum #'documentation))
          (code-chunk? #'code))
     (render-@* 0 section documentation code)]
    [(_ indent section documentation code)
     (and (let ([x (syntax->datum #'indent)]) 
            (and (exact? x) (integer? x) (> x -1)))
          (string? (syntax->datum #'section))
          (string? (syntax->datum #'documentation))
          (code-chunk? #'code))
     (render-@* indent section documentation code)]))))

(@ "
The \\.{@} control code is an unnamed section code. It works basically
like \\.{@*} but it does not accept a section name."

(@> "@ Definition" (output-procedures) ((@ render-@)) ()
(define-syntax @
  (syntax-rules ()
    [(_ code) 
     (code-chunk? #'code)
     (render-@ "" code)]
    [(_ documentation) 
     (string? (syntax->datum #'documentation))
     (render-@ documentation void)]
    [(_ documentation code)
     (and (string? (syntax->datum #'documentation))
          (code-chunk? #'code))
     (render-@ documentation code)]))))

(@ "
The \\.{@f} control code would normally be for controlling formatting of
code, but this is not enabled at the moment."

(@> "@f Definition" () (@f) ()
(define-syntax @f
  (lambda (x)
    (error #f "@f is not implemented yet.")))))

(@ "
The \\.{@s} control code would normally be for controlling formatting of
code, but this is not enabled at the moment."

(@> "@s Definition" () (@s) ()
(define-syntax @s
  (lambda (x)
    (error #f "@s is not implemented yet.")))))
    
(@ "
\\.{@c} Starts an unnamed code section."

(@> "@c Definition" (output-procedures) ((@c render-@c)) ()
(define-syntax @c
  (syntax-rules ()
    [(_ code ...)
     (render-@c code ...)]))))

(@ "
The \\.{@p} control code works just like \\.{@c} at the moment."

(@> "@p Definition" (output-procedures) ((@p render-@c)) ()
(define-syntax @p
  (syntax-rules ()
    [(_ code ...)
     (render-@c code ...)]))))

(@ "
The \\.{@l} control code is not yet supported."

(@> "@l Definition" () (@l) ()
(define-syntax @l
  (lambda (x)
    (error #f "@l is not implemented yet.")))))

(@ "
The \\.{@>} control code creates named chunks. This differs slightly
from CWEB in that we take into account the lexical positioning of a
chunk. Normally, a chunk is dynamically thrown into whatever environment
happens to surround a reference to it. This works for languages that are
loose with their scoping rules. This becomes a bit of a hassle in
Scheme, because we would like to know when free variables are captures,
what names will reference what bindings and so forth. To provide this, a
named chunk receives, in addition to the code, three lists. The first is
a list of the non-standard imports that extend the environment through
imports. The second is the bindings that should be visible outside of
the chunk. Thirdly, the other list should contain a list of the
variables that will be captured when inserted. These and only these
bindings will be scoped dynamically. Otherwise, all the bindings in the
definitions will refer to bindings in the default scope or one of the
imports that were listed.

If you are not used to thinking about your free variables, this could be
a problem. I wonder if there is a nicer way to do this, but at the
moment, named chunks are analogous to a module form. In fact, it is
expected that they will become module forms in the final code."

(@> "@> Definition" (output-procedures) ((@> render-@>)) ()
(define-syntax @>
  (syntax-rules ()
    [(_ name imports exports captures code ...)
     (string? (syntax->datum #'name))
     (render-@> name imports exports captures code ...)]))))

(@ "
The \\.{@->} control code is not yet supported."

(@> "@-> Definition" () (@->) ()
(define-syntax @->
  (lambda (x)
    (error #f "@-> is not implemented yet.")))))

(@ "
The \\.{@^} control code is not yet supported."

(@> "@^ Definition" () (@^) ()
(define-syntax @^
  (lambda (x)
    (error #f "@^ is not implemented yet.")))))

(@ "
The \\.{@.} control code is not yet supported."

(@.> "@. Definition" () (@.) ()
(define-syntax @.
  (lambda (x)
    (error #f "@. is not implemented yet.")))))

(@ "
The \\.{@:} control code is not yet supported."

(@> "@: Definition" () (@:) ()
(define-syntax @:
  (lambda (x)
    (error #f "@: is not implemented yet.")))))

(@ "
The \\.{@t} control code is not yet supported."

(@> "@t Definition" () (@t) ()
(define-syntax @t
  (lambda (x)
    (error #f "@t is not implemented yet.")))))

(@ "
The \\.{@!} control code is not yet supported."

(@> "@! Definition" () (@!) ()
(define-syntax @!
  (lambda (x)
    (error #f "@! is not implemented yet.")))))

(@ "
The \\.{@i} control code is not yet supported."

(@> "@i Definition" () (@i) ()
(define-syntax @i
  (lambda (x)
    (error #f "@i is not implemented yet.")))))
    
(@* "Program framework" "
The weave and tangle programs have a similar format. Each sets up the
appropriate environment for running the ChezWEB file, and then loads in
the specified file into the environment that has been created. The
environments bind the appropriate names so that all the output is sent
to the current output port."

(@> "Program Framework" (output-procedures) (compile-web-file) ()
(define (compile-web-file env input output)
  (eval `(with-output-to-file ,output 
           (lambda () 
             (load ,input)
             (generate-file))
           'replace)
        (environment env)))))

(@* "Utilities" "
Here are some little helpers that make life easier."

(@> "Utilities" () (code-chunk?) (@c @p @l)
(define (code-chunk? x)
  (syntax-case x (@c @p @l)
    [(@c rest ...) #t]
    [(@p rest ...) #t]
    [(@l rest ...) #t]
    [(rest ...) #f]
    [rest #f]))))
